{
  "version": 3,
  "sources": ["../../../src/lib/pages/screensaver.ts"],
  "sourcesContent": ["import * as Definition from '../const/definition';\nimport * as Types from '../types/types';\n\n//import dayjs from 'dayjs';\n//import moment from 'moment';\n//import parseFormat from 'moment-parseformat';\nimport { sendTemplates, weatherUpdateTestArray } from '../types/msg-def';\nimport { Page, PageInterface } from '../classes/Page';\nimport * as pages from '../types/pages';\nimport * as tools from '../const/tools';\nimport { PageItem } from './pageItem';\nimport { BaseClassTriggerd } from '../controller/states-controller';\n\nexport type ScreensaverConfigType = {\n    momentLocale: string;\n    locale: string; //Intl.DateTimeFormat;\n    iconBig1: boolean;\n    iconBig2: boolean;\n};\n\nexport class Screensaver extends Page {\n    items: undefined;\n    private step: number = 0;\n    private headlinePos: number = 0;\n    private titelPos: number = 0;\n    private nextArrow: boolean = false;\n    private rotationTime: number = 300000;\n    private timoutRotation: ioBroker.Timeout | undefined = undefined;\n    constructor(config: PageInterface, options: pages.PageBaseConfig) {\n        if (!options.config || (options.config.card !== 'screensaver' && options.config.card !== 'screensaver2'))\n            return;\n        switch (options.config.mode) {\n            case 'standard':\n            case 'alternate': {\n                config.card = 'screensaver';\n                break;\n            }\n            case 'advanced': {\n                config.card = 'screensaver2';\n                break;\n            }\n        }\n        config.alwaysOn = 'none';\n        super(config, options);\n\n        //moment.locale(this.config2.momentLocale);\n        this.rotationTime =\n            options.config.rotationTime !== 0 && options.config.rotationTime < 3\n                ? 3000\n                : options.config.rotationTime * 1000;\n    }\n\n    async init(): Promise<void> {\n        await super.init();\n    }\n\n    async update(): Promise<void> {\n        if (!this.visibility) {\n            this.log.error('get update command but not visible!');\n            return;\n        }\n\n        const config = this.config;\n        if (!config || (config.card !== 'screensaver' && config.card !== 'screensaver2')) return;\n        const message: pages.screensaverMessage = {\n            event: 'weatherUpdate',\n            options: {\n                indicator: [],\n                left: [],\n                time: [],\n                date: [],\n                bottom: [],\n                mricon: [],\n                favorit: [],\n                alternate: [],\n            },\n        };\n\n        if (this.pageItems) {\n            const model = config.model;\n            const layout = config.mode;\n            for (let a = 0; a < this.pageItems.length; a++) {\n                const pageItems: PageItem | undefined = this.pageItems[a];\n                const options = message.options;\n                if (pageItems && pageItems.config && pageItems.config.modeScr) {\n                    const place = pageItems.config.modeScr;\n                    const max = Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                    if (max === 0) continue;\n                    if (place === 'time' || place === 'date' || place === 'mricon') continue;\n                    if (\n                        Definition.ScreenSaverConst[layout][place].maxEntries[model] >\n                        ((options[place] && options[place]!.length) ?? 0)\n                    ) {\n                        const arr = options[place] || [];\n                        arr.push(await pageItems.getPageItemPayload());\n                        options[place] = arr;\n                    }\n                }\n            }\n            for (const x in message.options) {\n                const place = x as Types.ScreenSaverPlaces;\n                let items = message.options[place];\n                if (items) {\n                    const max = Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                    if (items.length > Definition.ScreenSaverConst[layout][place].maxEntries[model]) {\n                        let f = items.length / Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                        f = this.step % Math.ceil(f);\n                        items = items.slice(max * f, max * (f + 1) - 1);\n                    }\n                    for (let i = 0; i < max; i++) {\n                        const msg = items[i];\n                        if (!msg) {\n                            items[i] = tools.getPayload('', '', '', '', '', '');\n                        } else {\n                            const arr = items[i].split('~');\n                            arr[0] = '';\n                            arr[1] = '';\n                            items[i] = tools.getPayloadArray(arr);\n                        }\n                    }\n                }\n            }\n            if (message.options.alternate.length > 0)\n                message.options.alternate.unshift(tools.getPayload('', '', '', '', '', ''));\n            const arr: string[] = message.options.favorit.concat(\n                message.options.left,\n                message.options.bottom,\n                message.options.alternate,\n                message.options.indicator,\n            );\n            const msg = tools.getPayload(message.event, tools.getPayloadArray(arr));\n            this.sendToPanel(msg);\n            this.HandleScreensaverStatusIcons();\n        }\n    }\n\n    sendStatusUpdate(\n        payload: sendTemplates['statusUpdate'] | sendTemplates['weatherUpdate'],\n        layout: Types.ScreensaverModeType,\n    ): void {\n        switch (payload.eventType) {\n            case 'statusUpdate':\n                this.sendToPanel(\n                    tools.getPayload(\n                        payload.eventType,\n                        payload.icon1,\n                        payload.icon1Color,\n                        payload.icon2,\n                        payload.icon2Color,\n                        payload.icon1Font,\n                        payload.icon2Font,\n                        '',\n                    ),\n                );\n                break;\n            case 'weatherUpdate': {\n                let value = payload.value[layout];\n                if (!value) return;\n                const result: string[] = [payload.eventType];\n                const check = weatherUpdateTestArray![layout];\n                value = value.filter((item, pos) => check[pos]);\n                value.forEach((item, pos) => {\n                    const test = check[pos];\n                    if (item.icon && !test.icon) item.icon = '';\n                    if (item.iconColor && !test.iconColor) item.iconColor = '';\n                    if (item.displayName && (!('displayName' in test) || !test.displayName)) item.displayName = '';\n                    if (item.optionalValue && !test.icon) item.icon = '';\n                });\n                value.forEach(\n                    (a) =>\n                        a &&\n                        result.push(\n                            tools.getPayload(\n                                '',\n                                '',\n                                a.icon,\n                                a.iconColor,\n                                'displayName' in a ? a.displayName : '',\n                                a.optionalValue,\n                            ),\n                        ),\n                );\n                this.sendToPanel(tools.getPayloadArray([...result, '']));\n                break;\n            }\n        }\n    }\n    async onVisibilityChange(v: boolean): Promise<void> {\n        this.step = -1;\n        if (v) {\n            this.rotationLoop();\n        } else {\n            if (this.timoutRotation) this.adapter.clearTimeout(this.timoutRotation);\n        }\n        await super.onVisibilityChange(v);\n    }\n    rotationLoop = async (): Promise<void> => {\n        if (this.unload) return;\n        // only use this if screensaver is activated\n        if (!this.visibility) return;\n        if (this.step > 100) this.step = 0;\n\n        await this.update();\n\n        if (this.rotationTime === 0) return;\n        this.timoutRotation = this.adapter.setTimeout(\n            this.rotationLoop,\n            this.rotationTime < 3000 ? 3000 : this.rotationTime,\n        );\n    };\n\n    onStateTrigger = async (from: BaseClassTriggerd): Promise<void> => {\n        const config = this.config;\n        if (!config || (config.card !== 'screensaver' && config.card !== 'screensaver2')) return;\n        if (from instanceof PageItem && this.pageItems) {\n            const index = parseInt(from.id.split('?')[1]);\n            const item = this.pageItems[index];\n            if (item && item.config) {\n                const place = item.config.modeScr;\n                if (place !== undefined) {\n                    switch (place) {\n                        case 'left':\n                        case 'bottom':\n                        case 'indicator':\n                        case 'alternate':\n                        case 'favorit': {\n                            this.update();\n                            break;\n                        }\n                        case 'mricon': {\n                            this.HandleScreensaverStatusIcons();\n                            break;\n                        }\n                        case 'time': {\n                            break;\n                        }\n                        case 'date': {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    async HandleScreensaverStatusIcons(): Promise<void> {\n        {\n            if (!this.visibility) {\n                this.log.error('get update command but not visible!');\n                return;\n            }\n\n            const config = this.config;\n            if (!config || (config.card !== 'screensaver' && config.card !== 'screensaver2')) return;\n            const message: pages.screensaverMessage = {\n                event: 'weatherUpdate',\n                options: {\n                    indicator: [],\n                    left: [],\n                    time: [],\n                    date: [],\n                    bottom: [],\n                    mricon: [],\n                    favorit: [],\n                    alternate: [],\n                },\n            };\n\n            if (this.pageItems) {\n                const model = config.model;\n                const layout = config.mode;\n                for (let a = 0; a < this.pageItems.length; a++) {\n                    const pageItems: PageItem | undefined = this.pageItems[a];\n                    const options = message.options;\n                    if (pageItems && pageItems.config && pageItems.config.modeScr) {\n                        const place = pageItems.config.modeScr;\n                        const max = Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                        if (max === 0) continue;\n                        if (place !== 'mricon') continue;\n                        if (\n                            Definition.ScreenSaverConst[layout][place].maxEntries[model] >\n                            ((options[place] && options[place]!.length) ?? 0)\n                        ) {\n                            const arr = options[place] || [];\n                            arr.push(await pageItems.getPageItemPayload());\n                            options[place] = arr;\n                        }\n                    }\n                }\n                for (const x in message.options) {\n                    const place = x as Types.ScreenSaverPlaces;\n                    let items = message.options[place];\n                    if (items) {\n                        const max = Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                        if (items.length > Definition.ScreenSaverConst[layout][place].maxEntries[model]) {\n                            let f = items.length / Definition.ScreenSaverConst[layout][place].maxEntries[model];\n                            f = this.step % Math.ceil(f);\n                            items = items.slice(max * f, max * (f + 1) - 1);\n                        }\n                        for (let i = 0; i < max; i++) {\n                            const msg = items[i];\n                            if (!msg) {\n                                items[i] = tools.getPayload('', '', '', '', '', '');\n                            }\n                        }\n                    }\n                }\n                const mrIcon1 = message.options.mricon[0].split('~');\n                const mrIcon2 = message.options.mricon[1].split('~');\n                const msgArray: string[] = [\n                    'statusUpdate',\n                    mrIcon1[2] ?? '',\n                    mrIcon1[3] ?? '',\n                    mrIcon2[2] ?? '',\n                    mrIcon2[3] ?? '',\n                    mrIcon1[5] ?? '',\n                    mrIcon2[5] ?? '',\n                ];\n\n                const msg = tools.getPayloadArray(msgArray);\n                this.sendToPanel(msg);\n            }\n        }\n    }\n    /*\n        const payload: Partial<sendTemplates['statusUpdate']> = { eventType: 'statusUpdate' };\n        const maxItems = Definition.ScreenSaverConst[this.layout]['mrIconEntity'].maxEntries;\n        for (let i = 0; i < maxItems; i++) {\n            const s: '1' | '2' = i == 0 ? '1' : '2';\n            const item = this.items['mrIconEntity'][i];\n            if (item === null || item === undefined) {\n                payload[`icon${s}`] = '';\n                payload[`icon${s}Color`] = '';\n                payload[`icon${s}Font`] = '';\n                continue;\n            }\n\n            let value: number | boolean | string | null = await tools.getValueEntryNumber(item.entityValue);\n            if (value === null) value = await tools.getValueEntryString(item.entityValue);\n            if (value === null) value = await tools.getValueEntryBoolean(item.entityValue);\n\n            if (value === null) {\n                payload[`icon${s}`] = '';\n                payload[`icon${s}Color`] = '';\n                payload[`icon${s}Font`] = '';\n                continue;\n            }\n\n            const entity =\n                item.entityValue && item.entityValue.value\n                    ? item.entityValue.value.type == 'string'\n                        ? await item.entityValue.value.getString()\n                        : await item.entityValue.value.getBoolean()\n                    : null;\n            const offcolor =\n                item.entityIcon && item.entityIcon.false && item.entityIcon.false.color\n                    ? await item.entityIcon.false.color.getRGBDec()\n                    : String(Color.rgb_dec565(Color.White));\n            const onColor =\n                item.entityIcon && item.entityIcon.true && item.entityIcon.true.color\n                    ? await item.entityIcon.true.color.getRGBDec()\n                    : null;\n            payload[`icon${s}Color`] = offcolor !== null ? offcolor : String(Color.rgb_dec565(Color.White));\n            if (item.entityValue != null || value !== null || onColor != null) {\n                // Pr\u00FCfung ob Entity vom Typ String ist\n                if (entity != null && onColor) {\n                    if (typeof entity == 'string') {\n                        switch (entity.toUpperCase()) {\n                            case 'ON':\n                            case 'OK':\n                            case 'AN':\n                            case 'YES':\n                            case 'TRUE':\n                            case 'ONLINE':\n                                payload[`icon${s}Color`] = onColor;\n                                break;\n                            default:\n                        }\n                        // Alles was kein String ist in Boolean umwandeln\n                    } else {\n                        if (entity) {\n                            payload[`icon${s}Color`] = onColor;\n                        }\n                    }\n                }\n                const entityIconSelect: any | null = item.entityIconSelect\n                    ? await item.entityIconSelect.getObject()\n                    : null;\n\n                // Icon ermitteln\n                const onIcon =\n                    item.entityIcon && item.entityIcon.true && item.entityIcon.true.value\n                        ? await item.entityIcon.true.value.getString()\n                        : null;\n                const offIcon =\n                    item.entityIcon && item.entityIcon.false && item.entityIcon.false.value\n                        ? await item.entityIcon.false.value.getString()\n                        : null;\n                const selectIcon =\n                    typeof entity !== 'boolean' && entity !== null && entityIconSelect\n                        ? (entityIconSelect[entity] as string | undefined)\n                        : undefined;\n\n                if (selectIcon) {\n                    payload[`icon${s}`] = Icons.GetIcon(selectIcon);\n                    this.log.debug('SelectIcon: ' + JSON.stringify(payload), 'info');\n                } else if (entity && onIcon) {\n                    payload[`icon${s}`] = Icons.GetIcon(onIcon);\n                    this.log.debug('Icon if true ' + JSON.stringify(payload), 'info');\n                } else {\n                    if (offIcon) {\n                        payload[`icon${s}`] = Icons.GetIcon(offIcon);\n                        this.log.debug('Icon1 else true ' + JSON.stringify(payload), 'info');\n                    } else if (onIcon) {\n                        payload[`icon${s}`] = Icons.GetIcon(onIcon);\n                        this.log.debug('Icon1 else false ' + JSON.stringify(payload), 'info');\n                    }\n                }\n\n                if (value !== null && value !== undefined) {\n                    payload[`icon${s}`] += typeof value === 'string' ? value : '';\n                    const unit =\n                        item.entityValue && item.entityValue.unit ? await item.entityValue.unit.getString() : null;\n                    if (unit !== null) payload[`icon${s}`] += unit;\n                }\n            } else {\n                payload[`icon${s}Color`] = String(Color.rgb_dec565(Color.Black));\n            }\n            payload[`icon${s}Font`] = this.config2[`iconBig${s}`] ? '1' : '';\n        }\n        this.sendStatusUpdate(payload as sendTemplates['statusUpdate'], this.layout);\n    }*/\n    async delete(): Promise<void> {\n        await super.delete();\n        if (this.timoutRotation) this.adapter.clearTimeout(this.timoutRotation);\n    }\n}\n"],
  "mappings": "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",
  "names": ["arr", "msg"]
}
