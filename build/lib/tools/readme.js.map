{
  "version": 3,
  "sources": ["../../../src/lib/tools/readme.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport { requiredScriptDataPoints } from '../const/config-manager-const';\n\nexport async function generateAliasDocumentation(): Promise<void> {\n    const checkPath = '.dev-data';\n    let header = `| Channel role | State ID | common.type | common.role | required | common.write | description |  \\n`;\n    header += `| :---: | :--- | :--- | :--- | :---: | :---: | :--- |  \\n`;\n\n    if (fs.existsSync(checkPath)) {\n        let lastFolder = '';\n        let table = '# Table of contents\\n';\n        let readme = '';\n        for (const folder in requiredScriptDataPoints) {\n            const data = requiredScriptDataPoints[folder];\n            readme += `## ${folder}\\n`;\n            readme += header;\n            table += `* [${folder}](#${folder})\\n`;\n\n            for (const key in data) {\n                const row = data[key];\n                readme += `| **${folder == lastFolder ? '\"' : folder}** | ${key} | ${row.type}| ${row.role}  | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${row.description ? row.description : ''} | \\n`;\n                lastFolder = folder;\n            }\n        }\n        fs.writeFileSync('ALIAS.md', table + readme);\n    }\n}\n\n/*import ChannelDetector, { PatternControl, type DetectOptions, type Types } from '@iobroker/type-detector';\nimport {NspanelLovelaceUi} from '../types/NspanelLovelaceUi';\n\nexport async function testTypeDetector(adapter: NspanelLovelaceUi): Promise<void> {\n    const detector: ChannelDetector = new ChannelDetector();\n\n    //const keys = Object.keys(objects); // For optimization\n    const usedIds: string[] = []; // To not allow using of same ID in more than one device\n    const ignoreIndicators: string[] = ['UNREACH_STICKY']; // Ignore indicators by name\n    //const allowedTypes: Types[] = ['button', 'rgb', 'dimmer', 'light']; // Supported types. Leave it null if you want to get ALL devices.\n\n    const options: DetectOptions = {\n        objects: adapter.\n        id: 'hm-rpc.0.LEQ1214232.1', // Channel, device or state, that must be detected\n        _keysOptional: keys,\n        _usedIdsOptional: usedIds,\n        ignoreIndicators,\n        // allowedTypes,\n    };\n    const test = adapter.getStatesOfAsync\n    let controls: PatternControl[] | undefined | null = detector.detect(options);\n    if (controls) {\n        const cs = controls.map((control: PatternControl) => {\n            const id = control.states.find((state: DetectorState) => state.id).id;\n            if (id) {\n                console.log(`In ${options.id} was detected \"${control.type}\" with following states:`);\n                control.states\n                    .filter((state: DetectorState) => state.id)\n                    .forEach((state: DetectorState) => {\n                        console.log(`    ${state.name} => ${state.id}`);\n                    });\n\n                return { control, id };\n            }\n        });\n    } else {\n        console.log(`Nothing found for ${options.id}`);\n    }\n}*/\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,kCAAyC;AAEzC,eAAsB,6BAA4C;AAC9D,QAAM,YAAY;AAClB,MAAI,SAAS;AAAA;AACb,YAAU;AAAA;AAEV,MAAI,GAAG,WAAW,SAAS,GAAG;AAC1B,QAAI,aAAa;AACjB,QAAI,QAAQ;AACZ,QAAI,SAAS;AACb,eAAW,UAAU,sDAA0B;AAC3C,YAAM,OAAO,qDAAyB,MAAM;AAC5C,gBAAU,MAAM,MAAM;AAAA;AACtB,gBAAU;AACV,eAAS,MAAM,MAAM,MAAM,MAAM;AAAA;AAEjC,iBAAW,OAAO,MAAM;AACpB,cAAM,MAAM,KAAK,GAAG;AACpB,kBAAU,OAAO,UAAU,aAAa,MAAM,MAAM,QAAQ,GAAG,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,OAAO,IAAI,WAAW,MAAM,EAAE,MAAM,IAAI,YAAY,MAAM,EAAE,MAAM,IAAI,cAAc,IAAI,cAAc,EAAE;AAAA;AAClM,qBAAa;AAAA,MACjB;AAAA,IACJ;AACA,OAAG,cAAc,YAAY,QAAQ,MAAM;AAAA,EAC/C;AACJ;",
  "names": []
}
