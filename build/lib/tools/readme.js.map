{
  "version": 3,
  "sources": ["../../../src/lib/tools/readme.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport { requiredScriptDataPoints, requiredFeatureDatapoints } from '../const/config-manager-const';\n\nexport async function generateAliasDocumentation(): Promise<void> {\n    const checkPath = '.dev-data';\n    let header = `| Channel role | State ID | common.type | common.role | required | common.write | description |  \\n`;\n    header += `| :---: | :--- | :--- | :--- | :---: | :---: | :--- |  \\n`;\n\n    if (fs.existsSync(checkPath)) {\n        let lastFolder = '';\n        let table = '# Table of contents\\n';\n        let readme = '';\n        for (const folder in requiredScriptDataPoints) {\n            const data = requiredScriptDataPoints[folder];\n            readme += `### ${folder}\\n`;\n            readme += header;\n            table += `* [${folder}](#${folder})\\n`;\n\n            for (const key in data.data) {\n                const row = data.data[key];\n                readme += `| **${folder == lastFolder ? '\"' : folder}** | ${key} | ${row.type}| ${row.role}  | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${row.description ? row.description : ''} | \\n`;\n                lastFolder = folder;\n            }\n        }\n        let first = true;\n        for (const folder in requiredFeatureDatapoints) {\n            const data = requiredFeatureDatapoints[folder];\n            const data2 = requiredScriptDataPoints[folder];\n            if (!data2) {\n                console.log(`Feature ${folder} not found in requiredScriptDataPoints`);\n            }\n\n            let next = true;\n            for (const key in data.data) {\n                if (\n                    !data2 ||\n                    !data2.data[key] ||\n                    data2.data[key].type != data.data[key].type ||\n                    data2.data[key].role != data.data[key].role ||\n                    !!data2.data[key].required != !!data.data[key].required ||\n                    !!data2.data[key].writeable != !!data.data[key].writeable\n                ) {\n                    next = false;\n                    break;\n                }\n            }\n            if (next) {\n                continue;\n            }\n            if (first) {\n                table += `## Feature\\n`;\n                readme += `# Feature datapoints\\n`;\n            }\n            first = false;\n            readme += `### Feature: ${folder}\\n`;\n            readme += header;\n\n            table += `* [${folder}](#feature-${folder})\\n`;\n\n            for (const key in data.data) {\n                const row = data.data[key];\n                readme += `| **${folder == lastFolder ? '\"' : folder}** | ${key} | ${row.type}| ${row.role}  | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${row.description ? row.description : ''} | \\n`;\n                lastFolder = folder;\n            }\n        }\n        fs.writeFileSync('ALIAS.md', table + readme);\n    }\n}\n\n/*import ChannelDetector, { PatternControl, type DetectOptions, type Types } from '@iobroker/type-detector';\nimport {NspanelLovelaceUi} from '../types/NspanelLovelaceUi';\n\nexport async function testTypeDetector(adapter: NspanelLovelaceUi): Promise<void> {\n    const detector: ChannelDetector = new ChannelDetector();\n\n    //const keys = Object.keys(objects); // For optimization\n    const usedIds: string[] = []; // To not allow using of same ID in more than one device\n    const ignoreIndicators: string[] = ['UNREACH_STICKY']; // Ignore indicators by name\n    //const allowedTypes: Types[] = ['button', 'rgb', 'dimmer', 'light']; // Supported types. Leave it null if you want to get ALL devices.\n\n    const options: DetectOptions = {\n        objects: adapter.\n        id: 'hm-rpc.0.LEQ1214232.1', // Channel, device or state, that must be detected\n        _keysOptional: keys,\n        _usedIdsOptional: usedIds,\n        ignoreIndicators,\n        // allowedTypes,\n    };\n    const test = adapter.getStatesOfAsync\n    let controls: PatternControl[] | undefined | null = detector.detect(options);\n    if (controls) {\n        const cs = controls.map((control: PatternControl) => {\n            const id = control.states.find((state: DetectorState) => state.id).id;\n            if (id) {\n                console.log(`In ${options.id} was detected \"${control.type}\" with following states:`);\n                control.states\n                    .filter((state: DetectorState) => state.id)\n                    .forEach((state: DetectorState) => {\n                        console.log(`    ${state.name} => ${state.id}`);\n                    });\n\n                return { control, id };\n            }\n        });\n    } else {\n        console.log(`Nothing found for ${options.id}`);\n    }\n}*/\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,kCAAoE;AAEpE,eAAsB,6BAA4C;AAC9D,QAAM,YAAY;AAClB,MAAI,SAAS;AAAA;AACb,YAAU;AAAA;AAEV,MAAI,GAAG,WAAW,SAAS,GAAG;AAC1B,QAAI,aAAa;AACjB,QAAI,QAAQ;AACZ,QAAI,SAAS;AACb,eAAW,UAAU,sDAA0B;AAC3C,YAAM,OAAO,qDAAyB,MAAM;AAC5C,gBAAU,OAAO,MAAM;AAAA;AACvB,gBAAU;AACV,eAAS,MAAM,MAAM,MAAM,MAAM;AAAA;AAEjC,iBAAW,OAAO,KAAK,MAAM;AACzB,cAAM,MAAM,KAAK,KAAK,GAAG;AACzB,kBAAU,OAAO,UAAU,aAAa,MAAM,MAAM,QAAQ,GAAG,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,OAAO,IAAI,WAAW,MAAM,EAAE,MAAM,IAAI,YAAY,MAAM,EAAE,MAAM,IAAI,cAAc,IAAI,cAAc,EAAE;AAAA;AAClM,qBAAa;AAAA,MACjB;AAAA,IACJ;AACA,QAAI,QAAQ;AACZ,eAAW,UAAU,uDAA2B;AAC5C,YAAM,OAAO,sDAA0B,MAAM;AAC7C,YAAM,QAAQ,qDAAyB,MAAM;AAC7C,UAAI,CAAC,OAAO;AACR,gBAAQ,IAAI,WAAW,MAAM,wCAAwC;AAAA,MACzE;AAEA,UAAI,OAAO;AACX,iBAAW,OAAO,KAAK,MAAM;AACzB,YACI,CAAC,SACD,CAAC,MAAM,KAAK,GAAG,KACf,MAAM,KAAK,GAAG,EAAE,QAAQ,KAAK,KAAK,GAAG,EAAE,QACvC,MAAM,KAAK,GAAG,EAAE,QAAQ,KAAK,KAAK,GAAG,EAAE,QACvC,CAAC,CAAC,MAAM,KAAK,GAAG,EAAE,YAAY,CAAC,CAAC,KAAK,KAAK,GAAG,EAAE,YAC/C,CAAC,CAAC,MAAM,KAAK,GAAG,EAAE,aAAa,CAAC,CAAC,KAAK,KAAK,GAAG,EAAE,WAClD;AACE,iBAAO;AACP;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,MAAM;AACN;AAAA,MACJ;AACA,UAAI,OAAO;AACP,iBAAS;AAAA;AACT,kBAAU;AAAA;AAAA,MACd;AACA,cAAQ;AACR,gBAAU,gBAAgB,MAAM;AAAA;AAChC,gBAAU;AAEV,eAAS,MAAM,MAAM,cAAc,MAAM;AAAA;AAEzC,iBAAW,OAAO,KAAK,MAAM;AACzB,cAAM,MAAM,KAAK,KAAK,GAAG;AACzB,kBAAU,OAAO,UAAU,aAAa,MAAM,MAAM,QAAQ,GAAG,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,OAAO,IAAI,WAAW,MAAM,EAAE,MAAM,IAAI,YAAY,MAAM,EAAE,MAAM,IAAI,cAAc,IAAI,cAAc,EAAE;AAAA;AAClM,qBAAa;AAAA,MACjB;AAAA,IACJ;AACA,OAAG,cAAc,YAAY,QAAQ,MAAM;AAAA,EAC/C;AACJ;",
  "names": []
}
